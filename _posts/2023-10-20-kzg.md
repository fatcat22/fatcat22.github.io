---
layout: post
title:  "多项式承诺之 KZG"
categories: zkp
tags: 原创 zkp polynomial-commitment kzg 
author: fatcat22
mathjax: true
---

* content
{:toc}




# 1. 什么是多项式承诺

所谓多项式承诺，也就是某人向其他人去承诺，自己拥有某个多项式。比如我向别人承诺，我有一个多项式 $f(x)=3x^5+11x^3+4x+5$ 。但其实我不会把这个多项式的完整信息告诉别人，我只会承诺我有一个多项式 $f(x)$ ，具体是什么保密。

既然多项式具体信息是保密的，我又要做出承诺我有这个多项式，并要让别人相信这个承诺，我就要想办法来证明我的承诺。所以多项式承诺不仅仅是承诺，更是一种证明方式，即在不泄漏多项式任何信息的情况下，能够证明、能够让别人相信我有这个多项式的承诺。用符号化一点的语言就是：

> 我声称拥有一个多项式 $f(x)$ ，所以当其他人给我任意一个值 $z$ 时，我都可以给他返回 $y$ 值且 $y = f(z)$。在不公开 $f(x)$ 的情况下，我需要有一种方式让别人相信：我给出的 $y$ 值确实是我通过 $y = f(z)$ 计算出来的，而不是通过另一个多项式（比如 $f'(z)$ ）算出来的或其它方式给出来的（比如给个随机数糊弄别人）。如果可以让别人相信这一点，那么也可以说明我真的拥有这么一个多项式 $f(x)$ 。

这篇文章里我们要介绍的 KZG 就是证明多项式承诺的一种方案。KZG 多项式承诺方案来源于[这篇论文](https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf)，`KZG` 这个名字是论文的三位作者的 last name 的首字母凑在一起的，有时候也会被叫做「卡特承诺」或「 Kate 承诺」，因为 Kate 是论文的第一作者。下面我们来详细聊聊 KZG 的承诺方案。

# 2. KZG 承诺

我们刚才提到过，作为承诺者要做的是，当验证者给一个随机值 $z$ 时，承诺者可以返回 $y$ 且 $y = f(z)$ 。问题是如何让别人相信 $y$ 是承诺者真的用 $f(z)$ 算出来的，而不是用其它方式欺骗验证者。

作为验证者，我们会想既然 $f(z) = y$ ，那 $f(z) - y = 0$ 也肯定的成立的啦。所以如果让 $f(x)-y$ 变成一个新的多项式，比如 $r(x) = f(x) - y$ ，那么 $r(z) = 0$ 也肯定是成立的。也就是说，$r(x)$ 这个多项式有一个根 $x = z$ 。

多项式有一个特点，就是如果一个多项式有根 $a$ ，那么这个多项式肯定可以被 $x-a$ 整除（关于这方面的细节这里就不展开了，感兴趣的读者可以搜索[余式定理](https://baike.baidu.com/item/%E4%BD%99%E5%BC%8F%E5%AE%9A%E7%90%86/6817832)或[多项式除法](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95)方面的资料进行学习）。所以如果 $r(x)$ 有根 $x=z$ ，那么 $r(x)$ 肯定可以被 $x-z$ 整除，得到一个新的商多项式，即：

$$
q(x) = \frac{r(x)}{x-z} = \frac{f(x)-y}{x-z}
$$

整理这个等式，把除法变乘法，得到：

$$
q(x)(x-z) = f(x) -y
$$

但是有了这个等式有什么用呢？

作为验证者我们会想，承诺者不是号称拥有 $f(x)$ 嘛，那肯定也拥有 $q(x)$ 啦。如果我给承诺者一个 ta 不知道的值（假设记为 $s$），承诺者把 $q(s)$ 和 $f(s)$ 都提前计算出来并公开（公开意味着 $q(s)$ 和 $f(s)$ 的值再也不能变了）。然后当验证者发一个随机数 $z$ 发给承诺者时，ta 能返回 $y$ 并且通过上面等式的验证，即：

$$
q(s)(s-z) = f(s) - y
$$

验证者就可以相信承诺者的承诺了。（因为这个等式里，只有 $z$ 和 $y$ 可变，其它值都是不可变的；而 $z$ 是验证者给出来的，所以承诺者只有给出相之相应的 $y$ ，等式才能验证通过）。

不过你可能会有一个疑问 ：承诺者在收到 $z$ 以后，是不是只要通过 $y = f(s) - q(s)(s-z)$ 就可以算出 $y$ 值然后返回，并不需要通过 $f(z)$ 计算 $y$ 呀？乍看上去是这样的，但忽略了一个关键的前提，即 **承诺者是不知道 $s$ 的值的** ，所以 ta 是没法通过 $y = f(s) - q(s)(s-z)$ 计算出 $y$ 的，只能老老实实通过 $f(z)$ 计算。

所以问题又会变成，如何让承诺者不知道 $s$ 的值呢？因为从验证者的等式 $q(s)(s-z)=f(s)-y$ 看上去，验证者都好像是知道 $s$ 的（不然验证者怎么去计算等式两边的值是否相等呢？），如果验证者知道 $s$ ，怎么能保证承诺者不知道呢？（毕竟世界上没有不透风的墙.....）。还有，既然承诺者不知道 $s$ 的值，ta 又如何计算 $f(s)$ 和 $q(s)$ 呢？

如果你读过之前[关于 groth16 的文章](https://yangzhe.me/2023/10/15/non-interactive-prove/#2-trusted-setup)，就肯定知道，方法就是 trusted setup ，即利用多方计算的方式保证 $s$ 是保密的。而引入了 trusted setup ，自然也就需要引入同态加密和双线性配对。所以最终，承诺者需要使用 trusted setup 中的值和同态加密运算来计算 $q(s)$ 和 $f(s)$ 的值；而验证者需要使用双线性配对来验证 $q(x)(x-z) = f(x) -y$ 是否成立。

我们知道双线性配对的一个性质是 $e(g^a, h^b)=e(g,h)^{ab}$ ，所以我们可以将 $q(x)(x-z) = f(x) -y$ 变成如下的双线性配对等式（其中 $H$ 是第二个椭圆曲线的生成元）：

$$
e([q(s)]_1, [s-z]_2) = e([f(s)]_1-[y]_1, H)
$$

现在 $s$ 是保密的了，没人知道；并且引入双线性配对计算，承诺者也无法通过 $y= f(s) - q(s)(s-z)$ 计算出 $y$ 了。所以只要上面的双线性配对等式成立，验证者就可以相信，承诺者真的拥有多项式 $f(x)$ 。在这个等式里，$[f(s)]_1$ 被称为承诺，一般记为 $C$。

你可能还会想，既然 $e([q(s)]_1, [s-z]_2) = e([f(s)]_1-[y]_1, H)$ 是一个等式，并且除了 $[y]_1$ 这个值外，其它值承诺者也能算出来，那承诺者是不是也可以根据这个等式和其它值，反推出 $[y]_1$ 值呢？

# 3. 承诺者可以作假吗

为什么承诺者给出 $[y]_1$ 满足 $e([q(s)]_1, [s-z]_2) = e([f(s)]_1-[y]_1, H)$ 就可以相信承诺者拥有多项式 $f(x)$ 呢？难道承诺者不会作假吗？接下来我们就分析一下承诺者是否可以作假的问题。

承诺者作假有两种情况：一种是承诺者虽然没有 $f(x)$ 多项式，但他可以构造另外一个多项式 $f'(x)$ ，并从 $f'(x)$ 得到商多项式 $q'(x)$ ，最终 $[q'(s)]_1$ 和 $[f'(s)]_1$ 的值也可以让验证者验证通过；另一种情况是承诺者不构造任意多项式，就是根据验证者的验证方式 $e([q(s)]_1, [s-z]_2) = e([f(s)]_1-[y]_1, H)$  自己反推出 $[y]_1$ 的值。

我们先看第一种情况。承诺者根本没有多项式 $f(x)$ ，为了通过验证，ta 不得不构造另一个多项式 $f'(x)$ ，并希望 $f'(x)$ 可以通过验证。但如果 $f'(z) \ne y$ ，那么 $f'(x)$ 也肯定不能被 $x-z$ 整除，也就得不到商多项式 $q'(x)$ ，这肯定是没法验证的。

然后我们来看第二种情况，即根本不用任何多项式计算，只根据 $e([q(s)]_1, [s-z]_2) = e([f(s)]_1-[y]_1, H)$ 反推出 $[y]_1$ 。那要如何反推呢？由于承诺者也可以计算出 $[q(s)]_1$ 和 $[s-z]_2$ ，所以当然也可以计算出 $e([q(s)]_1, [s-z]_2)$ ，我们假设这个值是 $A$ ，所以 $A$ 对承诺者来说是已知的，那么承诺者要根据 $A = e([f(s)]_1 - [y]_1, H)$ 反推出 $[y]_1$ ，这个是几乎不可能的，所以也无法用这种方式作假（至于为什么几乎不可能这里就不详细展开了，感兴趣的读都可以搜索 `离散对数困难` 或 `q-strong SDH 假设`（[这篇论文](https://ai.stanford.edu/~xb/eurocrypt04a/bbsigs.pdf)2.3 小节） 相关主题进行学习）。


# 4. 总结
多项式承诺即是一种让别人相信自己拥有某个多项式的方式，所以这不仅是一种承诺，更是一种证明方式。KZG 承诺就是其中一种，它就是利用了多项式商运算的性质和未知的 $s$ 值。由未知的 $s$ 值又引出了 trusted setup 和双线性配对。

总之，在 KZG 中，$[f(s)]_1$ 被称为「承诺」，即 commitment ，而 $f(x)$ 在某个点（如 $z$ 点）的取值（如 $y$）则是承诺者要证明的事情。